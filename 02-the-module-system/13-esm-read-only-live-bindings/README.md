## Module loading in depth
  
  <p dir="rtl" align="right">
  برای درک نحوه عملکرد ESm و نحوه برخورد موثر با وابستگی های دایره ای کمی در مورد نحوه ارزیابی کد جاوا اسکریپت هنگام استفاده از ماژول ES صحبت می کنیم.
  </p>
  
  <p dir="rtl" align="right">
  چطور ماژول های ES لود می شوند، ایده read-only live binding رو ارائه می دهیم و مثالی از وابستگی های مدور می زنیم
  </p>
  
  ### Loading phases

<p dir="rtl" align="right">  
  هدف از مفسر ساخت یک گراف از همه ماژول های لازم (گراف وابستگی ) می باشد. 
  </p>
  
<p dir="rtl" align="right">
یک گراف وابستگی، یک گراف جهت دار است که وابستگی های گروهی از اشیا را نشان می دهند. گراف وابستگی، این امکان را می دهد که ترتیب بارگذاری همه ماژولهای لازم در یک پروژه مشخص را بدانیم. مفسر، از نقطه ورود تمامی دستورات ایمپورت را به صورت بازگشتی به طور عمیق پیدا میکند و دنبال میکند. 
</p>

<p dir="rtl" align="right">
سه فاز این عمل:
</p>

<p dir="rtl" align="right">
۱. ساخت یا تجزیه: همه موارد ایمپورت را پیدا کرده و محتوای هرماژول را به صورت بازگشتی از فایل مربوطه بازگذاری می کند
</p>

<p dir="rtl" align="right">
۲. برای هرموجودیت صادر شده، یک مرجع نام گذاری شده در حافظه نگه می دارد. اما هنوز هیچ مقداری ندارد. مرجع هایی هم برای همه اظهارات واردات و صادرات ایجاد میکند که رابطه وابستگی بین انها را دنبال میکند (پیوند دادن) هنوز کد JS اجرا نشده است.
</p>

<p dir="rtl" align="right">
۳. کد را اجرا میکند تا همه موجودیت های مرحله دوم بتوانند مقدار بگیرند. اکنون کد از نقطه شروع اجرا شده چون همه جاهای خالی پر شده است.
</p>

<p dir="rtl" align="right">
فازیک یافتن نقاط است فاز دوم: متصل کردن و فاز سوم: طی کردن و پرکردن 
</p>

<p dir="rtl" align="right">
این رویکرد ظاهرا تفاوتی با CommonJS ندارد با توجه به ماهیت پویای CommonJS تمامی پرونده ها را در حالی که نمودار وابستگی کاوش می شود اجرا می کند. به همبن دلیل هربار که یک نیاز جدید پیدا می شود کد قبلا اجرا شده است. به همین دلیل در دستور if یا حلقه ها از دستور require می توان استفاده کنید و شناسه های ماژول را از متغیرها بسازید. در ESM این سه مرحله از هم جداست و تا زمانی که نمودار وابستگی ساخته نشود هیچ کدی اجرا نمی شود پس واردات و صادرات ماژول باید ثابت باشد.
</p>

### Read-only live bindings

<p dir="rtl" align="right">
یک ویژگی دیگر ES که به وابستگی چرخه ای کمک میکند. در ماژول های  ES که به سیکل وابستگی کمک میکند این است که ماژول هایی که ایمپورت کرده‌ایم مقادیر فقط خواندنی را اکسورت میکنند
</p>

```
// counter.js
export let count = 0
export function increment () {
  count++
}
```

<p dir="rtl" align="right">
این ماژول دو مقدار را صادر می کند: یکی شمارنده ساده از نوع int به نام count و دیگری یک تابع increment که شمارنده را یکی افزایش می دهد.
</p>

``` 
// main.js
import { count, increment } from './counter.js'
console.log(count) // prints 0
increment()
console.log(count) // prints 1
count++ // TypeError: Assignment to constant variable!

```

<p dir="rtl" align="right">
می توانیم مقدار شمارنده را با تابع تغییر دهیم ولی به محض تغییر مستقیم خطا می دهد. وقتی یک موجودیت به یک محدوده وارد می شود اتصال به مقدار اصلی ان قابل تغییر نیست (فقط خواندنی) مگر اینکه مقدار bound شده در محدوده خود ماژول اصلی (live binding) تغییر کند.
</p>

<p dir="rtl" align="right">
ولی در CommonJS کل شی صادر شده در صورت نیاز از یک ماژول کپی (shallow copy) می شود. این بدین معناست که اگر متغیرهای اولیه تغییر کند ماژول مورد نظر قادر به مشاهده این تغییرات نیست. 
</p>

# 14-esm-read-only-live-bindings

This sample demonstrates that imported ESM modules are read-only live bindings

## Run

```bash
node main.js
node main.cjs
```
