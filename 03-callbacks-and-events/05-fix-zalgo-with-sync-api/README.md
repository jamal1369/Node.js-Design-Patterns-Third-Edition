<p dir="rtl" align="right">
اشکالی که به تازگی مشاهده کرده اید برای شناسایی در یک برنامه واقعی بسیار پیچیده است. تصور کنید از یک عملکرد مشابه در سرور وب استفاده می کنید جایی که چندین درخواست همزمان می توانید داشته باشید. تصور کنید برخی از ان درخواست ها را بدون هیچ دلیل ظاهری و یا خطایی (خطا ثبت نشده) به حالت تعلیق در اورده اید. این را می توان یک نقص ناخوشایند دانست.
</p>

<p dir="rtl" align="right">
این جور استفاده از عملکردهای غیرقابل پیش بینی شبیه zALGO می باشد.
</p>

### Using synchronous APIs

<p dir="rtl" align="right">
درسی که از مثال ازاد کننده زالگو می توان گرفت این است که برای api ها ماهیت ان را مشخص کنید. -همزمان یا ناهمزمان-
</p>

<p dir="rtl" align="right">
یک راه حل احتمالی برای تابع inconsistentRead() این است که ان را کاملا همزمان کنید. این امر امکان پذیر است زیرا nodejs مجموعه ای از API های سبک مستقیم همزمان را برای اکثر عملیات اولیه IO دارد. به عنوان مثال می توان از تابع fs.readFileSync() به جای همتای ناهمزمان ان استفاده کرد. کد به صورت زیر خواهد بود:
 </p>
 
```
import { readFileSync } from 'fs'

const cache = new Map()

function consistentReadSync (filename){
 if(cache.has(filename)){
   return cache.get(filename)
 }else{
   const data = readFileSync(filename, 'utf8')
   cache.set(filename, data)
   return data
   }
}
```

<p dir="rtl" align="right">
می بینید که کل تابع نیز به سبک مستقیم تبدیل شده است. اگر تابعی همزمان باشد دلیلی وجود ندارد که CPS داشته باشد. در واقع پیاده سازی یک API همزمان با استفاده از یک سبک مستقیم همیشه بهترین عمل است. این کار هرگونه سردرگمی در مورد ماهیت ان را از بین می برد و از نظر عملکرد نیز کارآمدتر خواهد بود
</p>


## Pattern

<p dir="rtl" align="right">
همیشه یک سبک مستقیم برای توابع کاملا همزمان انتخاب کنید
</P>

<p dir="rtl" align="right">
به خاطر داشته باشید که تغییر API از CPS به سبک مستقیم، یا از ناهمزمان به سنکرون یا بالعکس، ممکن است مستلزم تغییر سبک همه کدهای مورد استفاده باشد. به عنوان مثال، در مورد ما، مجبوریم رابط کاربری createFileReader() را کاملا تغییر دهیم و ان را طوری تنظیم کنیم که همیشه به طور همزمان کار کند
</P>

<p dir="rtl" align="right">
استفاده از یک API همزمان به جای ناهمزمان دارای برخی نکات است:
</P>

<p dir="rtl" align="right">
− یک api همزمان برای یک عملکرد خاص ممکن است همیشه در دسترس نباشد
</P>

<p dir="rtl" align="right">
− یک api همزمان حلقه رویداد را مسدود کرده و هرگونه درخواست همزمان را در حالت تعلیق قرار می دهد. این مدل همزمان نودجی اس را خراب میکند. و کل برنامه را کند می کند. در ادامه خواهید دید در برنامه های کاربردی ما این دقیقا به چه معناست. 
</P>

<p dir="rtl" align="right">
در تابع consistentReadSync() خطر مسدود کردن حلقه رویداد تاحدی کاهش می یابد. زیرا api ورودی/خروجی همزمان فقط یکبار در هر نام فایل فراخوانی می شود. در حالی که مقدار ذخیره شده برای همه فراخوانی های بعدی استفاده می شود. اگر تعداد محدودی فایل استاتیک داریم استفاده از consistentReadSync() تاثیر زیادی در حلقه رویداد ما نخواهد داشت. اگر مجبور باشیم فایل های زیادی را بخوانیم و فقط یکبار همه چیز به سرعت تغییر میکند.
 </P>
 
 <p dir="rtl" align="right">
استفاده از ورودی/حروجی همزمان در نودجی اس در بسیاری از شرایط به شدت دلسرد می شود. اما در برخی موارد این ممکن است ساده ترین و کارآمدترین راه حل باشد. همیشه مورد استفاده خاص خود را برای انتخاب جایگزین مناسب ارزیابی کنید. به عنوان مثال، کاملا منطقی است که از یک api مسدود کننده همزمان برای بارگیری یک فایل پیکربندی هنگام راه اندازی برنامه استفاده کنید. 
</P>

### PATTERN

<p dir="rtl" align="right">
از api های مسدود کننده به میزان اندک و تنها در مواردی که بر توانایی برنامه برای کنترل عملیات همزمان ناهمزمان تاثیر نمی گذارد استفاده کنید
</P>

# 05-fix-zalgo-with-sync-api

This example demonstrates how to fix Zalgo by making our unpredictable function synchronous.

## Run

To run the example launch:

```bash
node index.js
```
